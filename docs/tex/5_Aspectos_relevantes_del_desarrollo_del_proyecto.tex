\capitulo{5}{Aspectos relevantes del desarrollo del proyecto}

\section{Arquitectura del proyecto} \label{sec:arquitectura}

\subsection{Arquitectura de Microservicios} \label{sec:microservicios}
La planificación de la arquitectura sobre la cual se iba a desarrollar el proyecto quedó definida en las primeras fases de exploración de la idea. Su elección estuvo condicionada al cumplimiento de una serie de características que se planteaban como clave en el desarrollo de una plataforma moderna. Entre las propiedades de las que se pretendía dotar a la aplicación destacan las siguientes:

\begin{itemize}
    \item [\textbullet] \textbf{Bajo acoplamiento}. Se decidió buscar la separación entre sí de aquellos componentes que no dependiesen del resto para su ejecución. Una de las principales ventajas de este tipo de planteamientos reside en minimizar el impacto que puede tener una falla que se de en alguna de las fases del procesamiento que se llevan a cabo en el back-end. Otra de sus ventajas implica en proporcionar la posibilidad de optimizar los recursos a las necesidades de cada fase, asignando una menor cantidad de recursos para aquellas tareas de bajo coste computacional, y distribuyendo esos recursos en aquellos procesos que requieran de una mayor potencia de cálculo y/o almacenamiento.
    \item [\textbullet] \textbf{Mantenible y adaptable a cambios}. La esencia del proyecto resalta el concepto de experimentar con la aplicación de modelos de PLN a los sistemas de seguimiento de incidencia con el objetivo de lograr simplificar y mejorar partes del proceso. Esta propuesta deja abierta la posibilidad de incorporar nuevas tareas y funcionalidades a la plataforma de cara a un futuro, así como la actualización de modelos a nuevas implementaciones.
    \item [\textbullet] \textbf{Alta disponibilidad}. La extracción de los datos y la aplicación de los modelos de PLN son procesos que demandan de una cantidad moderada de tiempo para la realización de sus funciones. Estos retrasos no deben repercutir en la experiencia del usuario, al cual se le debe seguir permitiendo interactuar con la plataforma mientras estos procesos se ejecutan en segundo plano.
\end{itemize}

Con el afán de cumplir con la implementación de una arquitectura que cumpliese dotase a la plataforma de las características anteriormente mencionadas nos decantamos por una arquitectura basada en microservicios. Este patrón arquitectónico permite encapsular las diferentes tareas de la aplicación en servicios independientes con un alto nivel de especificidad.

Una de las ventajas principales reside en el hecho de que la separación del servicio API REST encargado de gestionar las peticiones desde la aplicación, de los servicios de extracción o procesado, permite atender y encolar peticiones mientras se atienden peticiones previas evitando generar tiempos muertos. La segunda virtud de este tipo de arquitectura otorga a los mantenedores de la plataforma la opción de duplicar servicios en caso de que la demanda de este tipo de tareas supere a la capacidad de procesamiento de los servicios actuales.

\subsection{Arquitectura dirigida por eventos} \label{sec:dirigida_por_eventos}

La decisión arquitectónica escogida entorno a la separación de los diferentes servicios en componentes trae consigo la necesidad de implementar algún mecanismo mediante el cual los componentes sean capaces de detectar cuando deben llevar a cabo sus labores. El mecanismo requerido nos condujo directamente a la implantación de una arquitectura basada en eventos.
Este patrón arquitectónico suele aplicarse en entornos asíncronos, es decir, que cuando se genera una petición esta no siempre va a poder ser atendida y resuelta en ese mismo instante. Las peticiones entrantes son atendidas por un agente, este se encarga de emitir un evento y redireccionarlo a la cola de tareas del correspondiente servicio. Por su parte, los servicios tienen la responsabilidad de atender a dichos eventos y actuar según proceda manteniendo un orden de acuerdo con las prioridades establecidas. Seguidamente se presentan los detalles de la implantación de este patrón en nuestro proyecto:

\vspace{-0.5cm}
\begin{itemize}
\item [\textbullet] \textbf{Agente generador de eventos}. El agente generador de eventos de nuestra plataforma es el servicio de API REST, el cual se encarga de atender las peticiones lanzadas por los usuarios a través de la web. Las peticiones son procesadas, retornando una respuesta informando de si esta ha sido aceptada o rechazada debido a algún tipo de error en los parámetros requeridos.  Ante una petición correcta el sistema genera una nueva entrada en la base de datos detallando el tipo de tarea que ha sido solicitada, y los atributos asociados a dicha tarea.
\item [\textbullet] \textbf{Canal de comunicación de eventos}. La implantación del canal a través del cual los servicios son conscientes de las peticiones entrantes es una tabla de la base de datos donde cada fila representa una nueva tarea asociada a un identificador único. En los atributos de cada entrada es donde se indica hacia qué servicio va dirigida la petición, una bandera que indica el estado en el que se encuentra (esperando, en proceso, resuelta, fallida o desactualizada).
\item [\textbullet] \textbf{Consumidores de eventos}. Los servicios consumidores de eventos son tanto el servicio de procesamiento como el de extracción. Estos servicios acceden de manera periódica a la base de datos en busca de nuevas peticiones que requieran de su atención. En el momento se detecta un nuevo evento estos recuperan los argumentos de la petición y actualizan su estado. Finalmente, una vez resuelta la petición actualizan el estado de la tarea de acorde a su resolución.
\end{itemize}

El alto grado sobre el cual se ha implementado la aplicación no se encuentra libre de inconvenientes. Entre ellos debemos destacar la necesidad del agente externo que lanza las solicitudes contra la API REST de encargarse también de recoger los datos consultando a dicho servicio actualizaciones sobre el estado en el que se encuentra su petición. Este efecto se ve mitigado debido a que será el servidor que maneja la aplicación web el encargado de realizar llamadas de manera periódica hasta que vea resuelta su petición.
